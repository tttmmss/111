——————————————————————————
1.Linux中用户模式和内核模式是什么含义


内核模式拥有更高权限
linux中内核本身处于内核模式，应用程序处于用户模式。内核模式的代码可以无限制地访问所有处理器指令集以及全部内存和I/O空间。如果用户模式的进程要享有此特权，它必须通过系统调用向设备驱动程序或其他内核模式的代码发出请求。另外，用户模式的代码允许发生缺页，而内核模式的代码则不允许。

2.动态库和静态库的区别和优缺点？
动态链接的优缺点：生成的可执行文件较小，但是对环境的依赖大，比如说我们用动态库生成一个可执行文件，我们把这个可执行文件放到另一个环境中，在这个环境里面是没有可执行文件里面用到的库文件的，那么这个可执行文件就允许不了了
静态链接的优缺点就刚好反过来，生成的可执行文件较大，但是对环境依赖小，因为使用静态库链接生成可执行文件时，会把静态库中的对应的内容直接链接到可执行文件中去，即使是把这个可执行文件放到没有相应的库的环境中去，也可以执行


——————————————————————————
1.说出下列名词的含义volatile，const, staic, extern
Volatile	易变变量修饰词,用于防止编译器优化被修饰的语句
	Const    常量修饰词,const修饰的变量的值不能被改变
	Staic	    静态修饰词,被staic修饰的语句访问范围和生存周期会发生改变
比如: static修饰的变量(全局/局部)都只会在进程运行时被执行一次;未初始化
		 的staic变量值为0;被static修饰的函数只能在当前文件中被调用
Extern	外部声明修饰词,用来告诉编译器被extern修饰的语句已在其它文件中被定义

2.利用宏实现MIN(x,y)，输出比较小的那个，如果x和y相等，那么输出x
	#define MIN(x,y)	((x)<=(y)?(x):(y))

——————————————————————————
1、请简要描述#include “” 和 #include <>的区别
include “” 默认在工程目录下查找头文件，如果没有找到会去系统目录下查找头文件
Include <> 默认在系统目录下查找头文件

2、请比较标准IO和系统IO的区别
1）标准IO是标准C库提供的一套对文件操作的接口，带缓冲区，只要开发环境中有标准C库，即可使用标准IO，可移植性强。标准IO只能操作普通文件
2）系统IO是由操作系统内核提供的一套操作文件的接口，不带缓冲区，各个操作系统平台提供的系统IO接口可能不一样，可移植性差。系统IO能够操作普通文件和设备文件、管道文件、socket文件

——————————————————————————
1、头文件中的ifndef/define/endif 的作用?
	#ifndef、#define、#endif为C语言的3条预处理语句，主要用作条件编译 	条件编译发生在预处理阶段，在C中，主要通过#if、#elif、#else、#ifdef、#ifndef、#endif来给一段代码附加上编译条件，然后预处理器收集满足条件的可以进行编译的代码，这样经过预处理，不满足条件的代码就不会被编译。
这三个预处理语句用在一起可以解决头文件被重复引用的问题：一个.c源程序中可能引用了多个头文件，而被源程序引用的头文件又有可能存在引用关系，比如a.h引用了b.h，然后在源程序中同时引用a.h和b.h，就会产生这个问题，这时编译器会产生符号重定义之类的错误。


2、extern全局变量、static全局变量和static局部变量的生存期分别是多少？ 
	Static 	声明的全局变量只能在当前源文件中使用;
extern 	不是定义, 是引入(声明)在其它源文件中定义的非 static 全局变量
Static  	局部变量只会被初始化一次,随进程的持续性

——————————————————————————
1.有以下代码
struct {
signed int bit0:1; signed int bit1:1; signed int bit2:1; signed int bit3:1; 
signed int bit4:1; signed int bit5:1; signed int bit6:1; signed int bit7:1;
}bits;
请问sizeof(bits)是否是正确的表达式？
请问语句bits mybits; 的定义是否正确？如果不正确，要如何修改上述的结构定义才能使该语句正确？修改后的结构定义是否会影响sizeof(bits)的正确性？如果正确则该表达式的值为多少？如果将上述的结构中int类型改为char类型，此时sizeof(bits)的大小为多少？
1）是正确的表达式，因为sizeof后面的内容可以是类型，也可以是变量。
2）该语句的定义不正确，因为此时的bits为一个变量；应该这样修改结构的定义 typedef struct {
signed int bit0:1; signed int bit1:1; signed int bit2:1; signed int bit3:1; signed int bit4:1; signed int bit5:1; signed int bit6:1; signed int bit7:1; }bits;
修改后sizeof(bits)表达式依然正确，其值为4；类型改为char后其值为1，注意该值是在VC环境中的32位程序中得到的值，在不同的编译器其值有可能不同，因此在编程时不能自己假定类似结构的大小。

2.有以下代码
struct a { int x;
char y;
struct a z; struct a *p;
}
请问这种定义结构正确否？ 如果有问题，问题在哪里？
答案：结构中不能对定义结构本身的非指针变量，如果编译器支持则会导致无限嵌套，因此一般编译器都会认为struct a是未定义的类型，即使提前声明也不会有任何用处。


——————————————————————————
1、用宏定义写出swap(x，y)，用来交换两个非指针变量的值。
	#define  swap(x, y)  {(x)=(x)+(y);(y)=(x)-(y);(x)=(x)-(y);}


2、请写出 float  x  与“零值”比较的 if  语句。 
const float EPSINON = 0.00001;                          
 if ((x >= - EPSINON) && (x <= EPSINON)                  
注意:不可将浮点变量用“==”或“！=”与数字比较，应该设法转化成“>=”或“<=”此类形式。

3、C++中，类有哪些默认成员函数？
1) 默认构造函数;
	2) 默认拷贝构造函数;
	3) 默认析构函数;
	4) 默认重载赋值运算符函数;
	5) 默认重载取址运算符函数;
	6) 默认重载取址运算符const函数;
	7) 默认移动构造函数(c++11);
	8) 默认重载移动赋值操作符函数(c++11);


——————————————————————————
1.C与C++各自是如何定义常量的?有什么不同? (const和define的区别)
正确答案： 
C中是使用宏#define定义， C++使用更好的const来定义。 
区别： 
1)const是有数据类型的常量，而宏常量没有，编译器可以对前者进行静态类型安全检查，对后者仅是字符替换，没有类型安全检查，而且在字符替换时可能会产生意料不到的错误(边际效应)。 
2)有些编译器可以对const常量进行调试， 不能对宏调试。

2. 用预处理指令#define 声明一个常数，用以表明 1 年中有多少秒（忽略闰年问题）
#define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL
我在这想看到几件事情：
1. #define 语法的基本知识（例如：不能以分号结束，括号的使用，等等）
2.懂得预处理器将为你计算常数表达式的值，因此，直接写出你是如何计算一年中有多少秒而不是计算出实际的值，是更清晰而没有代价的。
3.意识到这个表达式将使一个 16 位机的整型数溢出‐因此要用到长整型符号 L,告诉编译器这个常数是的长整型数。
4.如果你在你的表达式中用到 UL（表示无符号长整型），那么你有了一个好的起点 。记住，第一印象很重要。



——————————————————————————
1. 关键字 volatile 有什么含意?并给出三个不同的例子。
一个定义为 volatile 的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。
下面是 volatile 变量的几个例子：
a.并行设备的硬件寄存器（如：状态寄存器）
b.一个中断服务子程序中会访问到的非自动变量(Non‐automatic variables)
c.多线程应用中被几个任务共享的变量
回答不出这个问题的人是不会被雇佣的。这是区分 C 程序员和嵌入式系统程序员的最基本的问题。搞嵌入式的家伙们经常同硬件、中断、RTOS 等等打交道，所有这些都要求用
到volatile 变量。不懂得 volatile 的内容将会带来灾难。
假设被面试者正确地回答了这是个题，我将稍微深究一下，看一下这家伙是不是直正懂得 volatile 完全的重要性。
a.一个参数既可以是 const 还可以是 volatile 吗？解释为什么。
1.可以。一个例子是只读的状态寄存器。它是 volatile 因为它可能被意想不到地改变。它是 const 因为程序不应该试图去修改它。
b.一个指针可以是 volatile 吗？解释为什么。
	2. 可以。尽管这并不很常见。一个例子是当一个中服务子程序修改一个指向buffer的指针时。
c.下面的函数有什么错误：
int square(volatile int *ptr)
{
return *ptr * *ptr;
}
3.这段代码有点变态。这段代码的目的是用来返指针*ptr 指向值的平方，但是，由于*ptr 指向一个 volatile 型参数，编译器将产生类似下面的代码：
int square(volatile int *ptr)
{
int a,b;
a = *ptr;
b = *ptr;
return a * b;
}
由于*ptr 的值可能被意想不到地该变，因此 a 和 b 可能是不同的。结果，这段代码可能返不是你所期望的平方值！正确的代码如下：
long square(volatile int *ptr)
{
int a;
a = *ptr;
return a * a;
}

2. 请简述gcc的编译过程？
gcc编译过程分为4个阶段：预处理、编译、汇编、链接。
预处理：处理以#开头的行,主要有头⽂件包含、宏替换、条件编译、删除注释
编译：主要进⾏词法、语法、语义分析等，检查⽆误后将预处理好的⽂件编译成汇编⽂件。
汇编：将汇编⽂件转换成 ⼆进制⽬标⽂件
链接：将项⽬中的各个⼆进制⽂件+所需的库+启动代码链接成可执⾏⽂件 

——————————————————————————

1.嵌入式系统经常具有要求程序员去访问某特定的内存位置的特点。在某工程中，要求设
置一绝对地址为 0x67a9 的整型变量的值为 0xaa66。编译器是一个纯粹的 ANSI 编译器。写代码去完成这一任务。
这一问题测试你是否知道为了访问一绝对地址把一个整型数强制转换（typecast）为一指针
是合法的。这一问题的实现方式随着个人风格不同而不同。典型的类似代码如下：
int *ptr = (int *)0x67a9;
*ptr = 0xaa66;

2.中断是嵌入式系统中重要的组成部分，这导致了很多编译开发商提供一种扩展—让标准
C支持中断。具代表事实是，产生了一个新的关键字__interrupt。下面的代码就使用了__in
terrupt 关键字去定义了一个中断服务子程序(ISR)，请评论一下这段代码的。
__interrupt double compute_area (double radius)
{
double area = PI * radius * radius;
printf("\nArea = %f", area);
return area;
}
这个函数有太多的错误了：
1.ISR 不能返回一个值。如果你不懂这个，那么你不会被雇用的。
2.ISR 不能传递参数。如果你没有看到这一点，你被雇用的机会等同第一项。
3.在许多的处理器/编译器中，浮点一般都是不可重入的。有些处理器/编译器需要让额处的寄存器入栈，有些处理器/编译器就是不允许在 ISR 中做浮点运算。此外，ISR应该是短而有效率的，在ISR 中做浮点运算是不明智的。
4.与第三点一脉相承，printf()经常有重入和性能上的问题。如果你丢掉了第三和
第四点，不会太为难你的。不用说，如果你能得到后两点，那么你的被雇用前景越来越光
明了。
